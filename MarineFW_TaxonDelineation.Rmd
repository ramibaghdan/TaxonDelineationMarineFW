---
title: 'Is taxon delineation harder in the marine realm?Marine vs. freshwater DNA barcode sequence clustering patterns'
author: "Rami Baghdan"
date: "3/18/2021"
output: pdf_document
---

```{r setup, include=FALSE,echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE)
```


## R Markdown

```{r Load libraries, results='hide', message=FALSE, warning=FALSE}

#Install and load required libraries.

#install.packages("tidyverse")
library(tidyverse)
#install.packages("msa")
library(msa)
#install.packages("dplyr",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(dplyr)
#install.packages("clValid",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(clValid)
#install.packages("cluster",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(cluster)
#install.packages("phangorn",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(phangorn)
#install.packages("DECIPHER",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(DECIPHER)
#install.packages("vegan",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(vegan)
#install.packages("seqinr",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(seqinr)
#install.packages("stringr",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(stringr)
#install.packages("stringi",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(stringi)
#install.packages("ape",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(ape)
#BiocManager::install("Biostrings")
library(Biostrings)
#BiocManager::install("muscle")
library(muscle)
#install.packages("picante",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(picante)
#install.packages("data.table",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(data.table)
#install.packages("phytools",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(phytools)
#install.packages("foreach",repos="https://mirror.rcg.sfu.ca/mirror/CRAN/")
library(foreach)
#source("http://bioconductor.org/biocLite.R")
#BiocManager::install("annotate")
library(annotate)
#install.packages("factoextra")
library(factoextra)
#install.packages("sf")
library(sf)
#install.packages("spData")
library(spData) #For `world`, an sf MULTIPOLYGON object
library(maptools)
data(wrld_simpl)
#devtools::install_github("CNuge/coil", build_vignettes = TRUE)
library(coil)
#install.packages("dendextend")
library(dendextend)
#install.packages("colorspace")
library(colorspace)
#install.packages("ggplot2")
library(ggplot2)
#install.packages("hrbrthemes")
library(hrbrthemes)
#install.packages("ggalt")
library(ggalt)
#install.packages("formattable")
library(formattable)
#install.packages("rnaturalearth")
library("rnaturalearth")
#install.packages("rnaturalearthdata")
library("rnaturalearthdata")

#Set working directory.
setwd('~/Desktop/RA_Guelph/Project1')

#Set parameters.

#Define the amount of missing data that will accepted for this analysis. This parameter is defined as the proportion of a sequence comprised of Ns, after trimming off terminal Ns and removing all gaps (-). 0.01 is used as a starting value, which means sequences with up to 1% of Ns or gaps will be be retained.

missing.data <- 0.01

#Set bin.number variable. This would require taxonomic groups, whether at the class, order, or family level, to contain more than bin.number of BINS for each habitat type (Freshwater and Marine) to be included in the clustering pattern statistical analysis.

bin.number <- 2

#Specifying which model of molecular evolution will be used for estimating the distance matrix after sequence alignment. 
chosen.model <- "TN93"

#Define the clustering threshold used for the sequence data. 
clustering.threshold <- 0.02

#Define the method used for clustering. Here, we used single linkage clustering.
clustering.method <- "single"

```

```{r Data download and preliminary filtering, results = 'hide', message=FALSE, warning=FALSE}

#In this section, records for a taxonomic class of interest is downloaded from BOLD. Preliminary filtering of the data set removes low quality records (see below filter.records function for details).

####
#Example: Download Malacostraca records from BOLD.

#Malacostraca <- read_tsv("http://www.boldsystems.org/index.php/API_Public/combined?taxon=Malacostraca&geo=New%20Zealand&format=tsv")

#Write into file.

#write_tsv(Malacostraca , "Malacostracadownload")
####

#Read in the taxonomic data set saved in the working directory.

dataset <- read_tsv("bold_dataBranchioGlobal.tsv")

#Check unique BINs.
unique(dataset$bin_uri)

#Check how many records have a BIN.
sum(!is.na(dataset$bin_uri))

#Check the number of records.
length(dataset$processid)

#Summary of the data
summary(dataset)

#Check the unique marker codes present. In this study, we focused on COI-5P.
count.by.marker <- dataset %>%
  group_by(markercode) %>%
  summarize(n = length(processid)) %>%
  arrange(desc(n)) %>%
  print()

#Create preliminary record filter function to apply on multiple data sets if needed.

filter.records <- function(dataset) {
  
  #Function input: Original data set downloaded from BOLD (data frame).
  #Function output: Filtered data set (data frame).

  #Ensure dataset is in a data frame format.
  bold.data.set <- as.data.frame(dataset)
  
  #Filter out non-COI-5P sequences, sequences less than 500 bp (after end trimming Ns and gaps), sequences with >1% internal N content, and records lacking a BIN. This step ensures only suitable data is retained.
  
  filtered.records <- bold.data.set %>%
    filter(str_detect(bin_uri, "[:]")) %>% #Filter out records that don't have a BIN.
    filter(str_detect(nucleotides, "[ACGT]")) %>% #Filter out records without a nucleotide sequence.
    filter(!grepl("[^A|C|G|T|N|-]", nucleotides)) %>% #Filter out records containing letters different from A,C,G,T,N, and -. 
    filter(str_detect(markercode, "COI-5P")) %>% #Filter out non-COI-5P sequences.
  mutate(nucleotides2 = str_remove_all(nucleotides, "^N+|N+$|-")) %>% #Trim Ns and gaps at sequence ends.
  filter(str_count(nucleotides2, "N") <= (missing.data * str_count(nucleotides))) %>% #Include sequences with up to 1% of Ns only.
    filter(nchar(nucleotides2) > 499) #Filter out sequences with fewer than 500 base pairs after trimming.
  
  #Return filtered.records data set. 
  return(filtered.records)
  
}

#Execute function on data set.
filtered.records <- filter.records(dataset)

#Some checks after filtering to ensure function was executed correctly.

dim(filtered.records) #Check dimensions of the output object.
unique(filtered.records$markercode) #Check unique marker codes present (should be COI-5P).
sum(is.na(filtered.records$nucleotides2)) #Check if any records have missing sequences.
summary(str_count(filtered.records$nucleotides2)) 

#Number of records left after the above filter.
length(filtered.records$processid)

#Number of BINs present.
length(unique(filtered.records$bin_uri))

#Number of BINs prior to filtering.
length(unique(dataset$bin_uri))

```

```{r Habitat Assignments: WoRMS}

#In this section, environment data from WoRMS (speciesprofile.txt and taxon.txt) is used to assign a habitat type to each record (freshwater or marine).

#Read in the downloaded taxonomic information and environment profiles from WoRMS.
speciesworms<- read_tsv("speciesprofile.txt")
taxonworms <- read_tsv("taxon.txt")

#Obtain taxonID and scientificName columns from taxon data.
taxon.id.name <- taxonworms[,c("taxonID","scientificName")]

#Add scientificName as a column to filtered records data set (species name, if available).
filtered.records$scientificName <- filtered.records$species_name

#Join filtered records with taxonomic information and then environment information.
filtered.records2 <- dplyr::left_join(filtered.records, taxon.id.name, by="scientificName")
filtered.records2 <- dplyr::left_join(filtered.records2, speciesworms, by = "taxonID")

#Remove any duplicated rows by keeping only the unique recordIDs. In some cases, species have multiple entries in the worms database, but only one is required.
filtered.records2 <- filtered.records2[!duplicated(filtered.records2$recordID),]

#Check the number of records that received no taxonomic name from WoRMS.
sum(is.na(filtered.records2$taxonID))

#Initiate a habitat.worms.species column to assign designations according to species name.
filtered.records2$habitat.worms.species <- NA

#Convert NAs in the environment columns isMarine and isFreshwater to a numeric 0 to simplify the next step.
filtered.records2$isFreshwater[is.na(filtered.records2$isFreshwater)] <- 0
filtered.records2$isMarine[is.na(filtered.records2$isMarine)] <- 0

#Using environmentdata obtained from the WoRMS database for species names, assign freshwater, marine, or mixed designations to the habitat.worms.species column. The presence of a 1 in the isMarine/isFreshwater fields indicates presence of that species in that environment.

filtered.records2 <- within(filtered.records2, habitat.worms.species[isMarine == 0 & isFreshwater == 1] <- 'Freshwater')
filtered.records2 <- within(filtered.records2, habitat.worms.species[isMarine == 1 & isFreshwater == 0] <- 'Marine')
filtered.records2 <- within(filtered.records2, habitat.worms.species[isMarine == 1 & isFreshwater == 1] <- 'Mixed')
filtered.records2$habitat.worms.species[is.na(filtered.records2$habitat.worms.species)] <- "na"

#For records with no habitat.worms.species designation (ie., "na"), attempt to obtain habitat from the genus name, if available. 
filtered.records2$scientificName[filtered.records2$habitat.worms.species == "na"] <- filtered.records2$genus_name[filtered.records2$habitat.worms.species == "na"]

#Re-join with WoRMS taxonomic information.
filtered.records2 <- dplyr::left_join(filtered.records2, taxon.id.name, by="scientificName")

#Rename speciesworms taxonID column to allow for merge.
names(speciesworms)[1] <- "taxonID.y"
filtered.records2 <- dplyr::left_join(filtered.records2, speciesworms, by = "taxonID.y")

#Remove any duplicated rows by keeping only the unique recordIDs. In some cases, species have multiple entries in the worms database, but only one is required.
filtered.records2 <- filtered.records2[!duplicated(filtered.records2$recordID),]

#Initiate a habitat.worms.genus column to assign designations according to genus name.
filtered.records2$habitat.worms.genus <- NA

#Convert NAs in the environment columns isMarine.y and isFreshwater.y to a numeric 0 to simplify the next step. 
filtered.records2$isFreshwater.y[is.na(filtered.records2$isFreshwater.y)] <- 0
filtered.records2$isMarine.y[is.na(filtered.records2$isMarine.y)] <- 0

#Subset the records that have a designation using the species name (we recombine this later).
filtered.records2.species <- filtered.records2 %>% filter(habitat.worms.species != "na")
filtered.records2.nospecies <- filtered.records2 %>% filter(habitat.worms.species == "na")

#Provide genus habitat designation according to the WoRMS environment data.  
filtered.records2.nospecies <- within(filtered.records2.nospecies, habitat.worms.genus[isMarine.y == 0 & isFreshwater.y == 1] <- 'Freshwater')
filtered.records2.nospecies <- within(filtered.records2.nospecies, habitat.worms.genus[isMarine.y == 1 & isFreshwater.y == 0] <- 'Marine')
filtered.records2.nospecies <- within(filtered.records2.nospecies, habitat.worms.genus[isMarine.y == 1 & isFreshwater.y == 1] <- 'Mixed')
filtered.records2.nospecies$habitat.worms.genus[is.na(filtered.records2.nospecies$habitat.worms.genus)] <- "na"

#Recombine all records (those that had a species level habitat designation and those that did not).
filtered.records2 <- rbind(filtered.records2.species, filtered.records2.nospecies)

#Check counts of each habitat type at the species and genus level.
filtered.records2 %>% filter(habitat.worms.species == "Freshwater") %>% nrow()
filtered.records2 %>% filter(habitat.worms.species == "Marine") %>% nrow()
filtered.records2 %>% filter(habitat.worms.species == "Mixed") %>% nrow()
filtered.records2 %>% filter(habitat.worms.species == "na") %>% nrow()

filtered.records2 %>% filter(habitat.worms.genus == "Freshwater") %>% nrow()
filtered.records2 %>% filter(habitat.worms.genus == "Marine") %>% nrow()
filtered.records2 %>% filter(habitat.worms.genus == "Mixed") %>% nrow()
filtered.records2 %>% filter(habitat.worms.genus == "na") %>% nrow()

#Convert any NAs to a character na under the habitat type columns.
filtered.records2$habitat.worms.genus[is.na(filtered.records2$habitat.worms.genus)] <- "na"


#Save filtered set if needed.
#saveRDS(filtered.records2, "~/Desktop/RA_Guelph/Project1/filteredrecords2.RData")
```


```{r Habitat Assignments: latitude, longitude, habitat, region, and exact site fields, message=FALSE, results = 'hide', warninng=FALSE}

#Using latitude and longitude data, we assigned habitat designations to each record.

#First, determine whether a record was obtained over land or ocean using latitude and longitude values. Here, we are making the assumption that records obtained over land are freshwater species and those in seas/oceans are marine species. Of course, coastal habitats are more ambiguous, so this habitat designation was given the lowest priority over the other methods used. 

#To obtain GPS based habitat information, only records containing latitude and longitude are retained.

#Obtain row indices of missing latitude or longitude values (both are required).
missingcoord <- which(is.na(filtered.records2$lat) | is.na(filtered.records2$lon))

#Subset records with coordinates and those without.
filtered.records.coord <- filtered.records2[-missingcoord,]
filtered.records.no.coord <- filtered.records2[missingcoord,]

#Determine whether a record was obtained in the ocean or land using the sf library.

#Obtain latitude and longitude values.
lat <- filtered.records.coord$lat
lon <- filtered.records.coord$lon

#Place the values into a data frame.
points <- data.frame("Var1" = lon, "Var2" = lat)

#Convert latitude and longitude points into an sf object.
pts <- st_as_sf(points, coords=1:2, crs = 4326)

#Find which points fall over land
ii <- !is.na(as.numeric(st_intersects(pts, world)))

#Check results. TRUE values represent samples obtained over land (based on GPS coordinates) and FALSE values represent samples obtained over ocean/sea.
check <- data.frame("region" = filtered.records.coord$region, "lat" = lat, "lon" = lon, "land" = ii)

#Combine GPS results with record information.
filtered.records.coord$land <- ii

#Records with no GPS information would not have results in this case.
filtered.records.no.coord$land <- NA

#Recombine records with GPS coordinates with those without.
filtered.records2 <- rbind(filtered.records.coord, filtered.records.no.coord)

#Initiate column for habitat.type.gps.
filtered.records2$habitat.type.gps <- NA

#Assign habitat designation for records with GPS coordinates (habitat.type.gps). 
#TRUE -> Freshwater/ FALSE -> Marine/  NA -> na
filtered.records2$habitat.type.gps[filtered.records2$land == TRUE] <- "Freshwater"
filtered.records2$habitat.type.gps[filtered.records2$land == FALSE] <- "Marine"
filtered.records2$habitat.type.gps[is.na(filtered.records2$land)] <- "na"

#Next, use region, habitat, and exact site columns in each data set to obtain a habitat designation as well. 

#First, strings across the habitat, region, exact site, and sector columns are combined. 
filtered.records2$habitat.region <- paste(filtered.records2$habitat, filtered.records2$region, filtered.records2$exactsite, sep=" ")

#Convert habitat.region column into character values.
filtered.records2$habitat.region <- as.character(filtered.records2$habitat.region)




### FOR ACTINOPTERYGII data set:

#Some records have invalid characters in the habitat.region column and need to be manually removed.

#Find invalid character for Actinopterygii
check <- filtered.records2 %>% filter(grepl("NA Para",habitat.region))
check <- filtered.records2 %>% filter(grepl("NA Terre Ad",habitat.region))
check <- filtered.records2 %>% filter(grepl("NA Upper Paran",habitat.region))
check <- filtered.records2 %>% filter(grepl("Pointe G", habitat.region))
check <- filtered.records2 %>% filter(grepl("Lafayette New Lake", habitat.region))

#filtered.records2 <- filtered.records2 %>% filter(recordID != c(1223717,1758336,1758335,1758378))
#filtered.records2 <- filter(filtered.records2, !(recordID %in% c(1223717,1249483, 1223714,1758336,1758335,1758334, 2454895, 2454891,2454896, 2454898,1758378,1223713,1758338,748177)))
###




#Convert habitat.region to lower case letters for consistency.
filtered.records2$habitat.region <- tolower(filtered.records2$habitat.region)

#Create data frame where the first column contains the unique habitat.region values and the second column will include the habitat type "Freshwater" or "Marine".
habitat.dict <- data.frame("habitat" = c(as.character(unique(filtered.records2$habitat.region))), "type" = "na")

#Change NAs to characters.
habitat.dict[is.na(habitat.dict)] = "na"
filtered.records2$habitat.region[is.na(filtered.records2$habitat.region)] = "na"


####
#Check what key terms in habitat.region could be used. 
#vague.habitat.regions <- filtered.records2 %>% filter(!grepl("Lake",habitat.region)) %>% filter(!grepl("Sea",habitat.region)) %>% filter(!grepl("River",habitat.region)) %>% filter(!grepl("Ocean",habitat.region)) %>% filter(!grepl("Coast",habitat.region)) %>% filter(!grepl("coast",habitat.region)) %>% filter(!grepl("Estuary",habitat.region)) %>% filter(!grepl("estuary",habitat.region))

#Check how many records are from each habitat.region. 
#sort(table(vague.habitat.regions$habitat.region))
####



#Next, using key terms, habitat.region names are given a "Freshwater" or "Marine" designation. Strings containing one of the phrases "lake" or "river" or "pond" or "stream" or "farm dam" or "brook" are classified as "Freshwater", whereas strings containing one of the phrases "ocean","sea","estuary","estuarine",and "coast" are classified as "Marine". *Estuaries are classified as marine (brackish) for the purposes of this project.

#Source: #https://stackoverflow.com/questions/27157858/r-look-for-a-string-on-multiple-conditions-and-replace-it-in-a-new-colum

#Ensure characters in both columns are lower case.
habitat.dict$habitat <- tolower(habitat.dict$habitat)
habitat.dict$type <- tolower(habitat.dict$type)

#Create the data frame dictionary according to the terms and phrases.
habitat.dict <- mutate(habitat.dict,
                type = "na",
                type = ifelse(grepl("lake", habitat) | grepl("river", habitat)| grepl("stream", habitat) | grepl("pond", habitat) | grepl("farm dam", habitat)| grepl("brook", habitat) | grepl("freshwater",habitat), "Freshwater", type),
                type = ifelse(grepl("ocean", habitat) | grepl("sea", habitat) | grepl("intertidal", habitat) | grepl("coast", habitat) | grepl("estuary", habitat) | grepl("estuarine", habitat) | grepl("marine",habitat), "Marine",type))

#Function to classify regions as freshwater or marine according to the dictionary created. 
habtype <- function(habitat) {
  
  #Input: habitat.region character vector
  #Output: habitat type character vector (Marine or Freshwater or na)
  
  type <- habitat.dict[habitat.dict$habitat == habitat,][[2]]
  return(type)
  
}

#View the habitat dictionary. 
habitat.dict

#Obtain habitat type for all records.
habitat.type <- lapply(filtered.records2$habitat.region, habtype) %>% unlist()

#Add a new column into the filtered data set that includes the habitat types according to habitat.region descriptions.
filtered.records2$habitat.type.habreg <- habitat.type

#Count the number of records with a habitat designation.
filtered.records2 %>% filter(habitat.type.habreg != "na") %>% nrow()

#Check unique habitat types assigned.
unique(filtered.records2$habitat.type.habreg)

#Next, we assigned a final habitat designation according to the following priority: 1.habitats from WoRMS -> 2. habitats from habitat, region, and exact site fields -> 3. habitats from GPS data.

#Create new column to place final habitat designation in.
filtered.records2$habitat.final <- NA

##Subset records that have a Marine or Freshwater designation according to the WoRMS data (at both species and genus level).

#1. Obtain records that received a Marine or Freshwater designation according to species name.

worms.index.species <- which(filtered.records2$habitat.worms.species == "Marine" | filtered.records2$habitat.worms.species == "Freshwater")

filtered.records2.worms.species <- filtered.records2[worms.index.species,]

#2. Obtain records that did not receive a designation at the species level but did receive either a Marine, Freshwater designation at the genus level. 

worms.index.genus <- which(filtered.records2$habitat.worms.species == "na" & (filtered.records2$habitat.worms.genus == "Marine" | filtered.records2$habitat.worms.genus == "Freshwater"))

filtered.records2.worms.genus <- filtered.records2[worms.index.genus,]

#3. Obtain records with no habitat designation at the species level ("na") but a Mixed designation at the genus level. These may receive a final habitat designation depending on the other designations derived from habitat/region/exact-site and GPS information.

worms.index.mixed.genus <- which(filtered.records2$habitat.worms.species == "na" & filtered.records2$habitat.worms.genus == "Mixed")

filtered.records2.worms.mixed.genus <- filtered.records2[worms.index.mixed.genus,]

#4. For this study, records receiving a mixed designation at the species level will recieve a final habitat designation of "na" regardless of other designations obtained using habitat/region/exact-site or GPS information.

worms.index.mixed.species <- which(filtered.records2$habitat.worms.species == "Mixed")
filtered.records2.worms.mixed.species <- filtered.records2[worms.index.mixed.species,]

#5. Obtain records that received an "na" designation at both the species and genus level. 

noworms.index <- which(filtered.records2$habitat.worms.species == "na" & filtered.records2$habitat.worms.genus == "na")

filtered.records2.noworms <- filtered.records2[noworms.index,]


#Check if the 5 data frames are mutually exclusive. 

total <- sum(length(worms.index.species) + length(worms.index.genus) + length(worms.index.mixed.genus) + length(worms.index.mixed.species) + length(noworms.index))
total2 <- length(filtered.records2)
total == total2

#The data is now split into five distinct data frames. 
#1. Records that have a marine/freshwater designation at the species level
#2. Records that have an na designation at the species level, but a marine/freshwater designation at the genus level.
#3. Records that have an na designation at the species level, but a mixed designation at the genus level (GPS and habitat/region/exact-site data will help determine the final designation)
#4. Records receiving a mixed designation at the species level (these will automatically receive a final designation of na)
#5. Records receiving no designation at both the species and genus level (GPS and habitat/region/exact-site information will be used to determine a final designation)

#Three of five of these data sets (1, 2, and 4 above) are ready to receive a final designation according to the priority order put in place where WoRMS-derived habitat designations take precedence. 

#Add the species-level WoRMS habitat designation as the final habitat designation if it is Freshwater or Marine.

filtered.records2.worms.species$habitat.final <- filtered.records2.worms.species$habitat.worms.species

#Add the genus-level WoRMS habitat designation if it is Freshwater or Marine, but species-level is na.

filtered.records2.worms.genus$habitat.final <- filtered.records2.worms.genus$habitat.worms.genus

#Add "na" as a final habitat designation if the species-level WoRMS designation is Mixed.

if (length(filtered.records2.worms.mixed.species$processid > 0)) {
  
  filtered.records2.worms.mixed.species$habitat.final <- "na"
}

#For records that have no habitat designation at the species level ("na") but a Mixed designation at the genus level, they may receive a final habitat designation depending on the other designations derived from habitat.type.habreg and habitat.type.gps columns.

#If both designations derived from GPS and habitat/region are the same (both Freshwater or both Marine), then assign a final habitat designation.

filtered.records2.worms.mixed.genus <- within(filtered.records2.worms.mixed.genus, habitat.final[habitat.type.gps == 'Freshwater' & habitat.type.habreg == 'Freshwater'] <- 'Freshwater')

filtered.records2.worms.mixed.genus <- within(filtered.records2.worms.mixed.genus, habitat.final[habitat.type.gps == 'Marine' & habitat.type.habreg == 'Marine'] <- 'Marine')

#Any other records that do not meet either of the above two criteria received a final designation of "na" due to conflicting/limited habitat designations.

filtered.records2.worms.mixed.genus$habitat.final[is.na(filtered.records2.worms.mixed.genus$habitat.final)] <- "na"

table(filtered.records2.worms.mixed.genus$habitat.final)

#For records that do not receive a habiat designation using the WoRMS data, we must rely on the other two habitat designations (those derived from GPS data and those derived from the habitat/region/exact-site fields in the data set). To determine a final habitat designation for each record, data is subset depending on agreement/disagreement between the two habitat designations. We prioritize data coming from the habitat/region fields over GPS data.

#Subset records in which the two habitat designations agree.
same.designation <- filtered.records2.noworms %>% filter(habitat.type.gps == habitat.type.habreg)

#Subset records where there are no habitat designations.
no.designation <- filtered.records2.noworms %>% filter(habitat.type.gps == "na" & habitat.type.habreg == "na")

#Next, subset records where there is no GPS habitat derived designation but there is a habitat/region/exact-site derived designation.
gps.missing <- filtered.records2.noworms %>% filter(habitat.type.gps == "na" & habitat.type.habreg != "na")

#Likewise, subset records where there is a GPS habitat derived designation but no habitat/region/exact-site derived designation.
habreg.missing <- filtered.records2.noworms %>% filter(habitat.type.gps != "na" & habitat.type.habreg == "na")

#Lastly, subset the records where there is are both GPS and habitat/region derived designations, but they disagree.
mixed.designation <- filtered.records2.noworms %>% filter(habitat.type.gps != habitat.type.habreg) %>% filter(habitat.type.gps != "na" & habitat.type.habreg != "na")

###

#Place the final habitat designation in new column based on GPS derived and habitat/region/exact-site derived habitat designations.

###

#If both habitat designations are the same (Freshwater or Marine or na), the record will receive that same habitat designation as final.

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Freshwater' & habitat.type.habreg == 'Freshwater'] <- 'Freshwater')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Marine' & habitat.type.habreg == 'Marine'] <- 'Marine')

#If a record has no GPS derived habitat designation but a habitat/region/exact-site derived designation (Marine or Freshwater), the record will recieve the habitat/region/exact-site designation, and vice-versa.

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'na' & habitat.type.habreg == 'na'] <- 'na')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'na' & habitat.type.habreg == 'Freshwater'] <- 'Freshwater')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'na' & habitat.type.habreg == 'Marine'] <- 'Marine')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Freshwater' & habitat.type.habreg == 'na'] <- 'Freshwater')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Marine' & habitat.type.habreg == 'na'] <- 'Marine')

#Lastly, if the two habitat designations disagree, the final designation will be that of the habitat/region/exact-site derived designation. This is because GPS derived designations may be ambiguous along coastlines.

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Marine' & habitat.type.habreg == 'Freshwater'] <- 'Freshwater')

filtered.records2.noworms <- within(filtered.records2.noworms, habitat.final[habitat.type.gps == 'Freshwater' & habitat.type.habreg == 'Marine'] <- 'Marine')

#Now that a final habitat designation has been assigned to all 5 data sets, they can be recombined.

filtered.records2 <- rbind(filtered.records2.worms.species, filtered.records2.worms.genus, filtered.records2.worms.mixed.species, filtered.records2.worms.mixed.genus, filtered.records2.noworms)
```

```{r BIN-level habitat assignments according to sample size critera, message=FALSE, results = 'hide', warning=FALSE}

###

#BIN-level habitat designations

###

#In this section, habitat types are assigned to an entire BIN (instead of only each record). If there is a conflict of habitat types across records within a BIN, the designation making up 80% or more of the records with a habitat type is assigned to the entire BIN. Otherwise, an "na" is assigned. Afterwards, we retain families (or orders) that have at least 3 BINs of each habitat type (or any other number specified in the parameter section).

#Obtain number of records in each BIN by habitat designation.
filtered.records2 <- filtered.records2 %>% group_by(bin_uri, habitat.final) %>% mutate(count = n())

#Obtain relevant columns "bin_uri","habitat.final", and "count" to simplify next steps.
bin.habitat.counts <- filtered.records2[,c("bin_uri","habitat.final","count")]

#Obtain total number of records in each BIN.
bin.habitat.counts2 <- bin.habitat.counts %>% group_by(bin_uri) %>% mutate(count2 = n())

#Obtain distinct rows to focus only on unique BIN, habitat, and counts combination.
unique.bin.hab.counts <- distinct(bin.habitat.counts2)

#Obtain the habitat percentages for each BIN (proportion of records having a Marine, Freshwater, or na designation).
unique.bin.hab.counts$percent.habitat <- unique.bin.hab.counts$count/ unique.bin.hab.counts$count2 * 100

#Subset BINs where all records have the same habitat designation (whether it is na, Marine, or Freshwater).
mono.hab.type <- unique.bin.hab.counts %>% filter(percent.habitat == 100)

#Subset BINs where there is a disagreement in habitat designation among records.
mix.hab.type <- unique.bin.hab.counts %>% filter(percent.habitat < 100)

#Obtain BINs where the disagreement is between na and Freshwater or Marine. In this case, some records have a missing designation (na) but there is no Marine/Freshwater disagreement. 
mix.hab.type1 <- mix.hab.type %>% filter(habitat.final != "na") %>% group_by(bin_uri) %>% mutate(count3 = n()) %>% filter(count3 == 1)

#Among the mixed habitat BINs with both Marine and Freshwater records, obtain BINs where more than 80% of non-na designations are Marine or Freshwater.

mix.hab.type2 <- mix.hab.type %>% filter(habitat.final != "na") %>% group_by(bin_uri) %>% mutate(count3 = n()) %>% filter(count3 == 2) %>% mutate(count.fresh.marine = sum(count)) %>% mutate(percent.habitat.freshmarine = count/count.fresh.marine *100) %>% top_n(1, percent.habitat.freshmarine) %>% filter(percent.habitat.freshmarine > 80)

#Re-combine the mixed habitat BINs with the homogenous habitat BINs (those BINs outside of these two data sets will be given an "na" habitat designation).
hab.type.per.bin <- rbind(mono.hab.type, mix.hab.type1, mix.hab.type2)
unique(hab.type.per.bin$bin_uri)

#Merge habitat type and percentage data with original data containing record information.
filtered.records3 <- dplyr::left_join(filtered.records2, hab.type.per.bin, by = "bin_uri")

#Check to see if this worked. Each unique BIN should now have one habitat designation applied to all records.  

#test <- filtered.records3 %>% filter(bin_uri == "BOLD:AAB0750")

#Check unique habitat types.
unique(filtered.records3$habitat.final.y)

#Change NAs to na for consistency.
filtered.records3$habitat.final.y[is.na(filtered.records3$habitat.final.y)] = "na"

unique(filtered.records3$habitat.final.y)

#Obtain BINs with both a habitat designation and 5 or more sequences.

relevant.bins <- filtered.records3 %>% group_by(bin_uri) %>% filter(habitat.final.y != "na") %>% tally() %>% filter(n > 4)

#Inner join relevant.bins with hab.type.per.bin to obtain habitat type for each BIN.
relevant.bins2 <- dplyr::inner_join(relevant.bins, hab.type.per.bin, by = "bin_uri")

#Check how many BINs are marine vs freshwater.
relevant.bins2 %>% filter(habitat.final == "Marine") %>% nrow()
relevant.bins2 %>% filter(habitat.final == "Freshwater") %>% nrow()

#Re-combine with filtered records data set.
filtered.data.relevant <- dplyr::inner_join(filtered.records3, relevant.bins, by = "bin_uri")
length(unique(filtered.data.relevant$bin_uri))

#Among the retained BINs, check whether the next taxonomic rank (order) meets the sample size critera.
order.check <- filtered.data.relevant %>% group_by(order_name, bin_uri) %>% tally()

#Include habitat information as well.
order.habitat <- dplyr::inner_join(order.check, hab.type.per.bin, by = "bin_uri")

#Check for orders where there are 3 or more BINS for each habitat (Freshwater and Marine).

relevant.orders <- order.habitat %>% 
  group_by(order_name, habitat.final) %>% 
  mutate(myorder = n()) %>% filter(myorder > bin.number) %>% distinct(order_name) %>% ungroup(habitat.final) %>% mutate(ordercount = n()) %>% filter(ordercount > 1) %>% ungroup(order_name) %>% dplyr::select(order_name) %>% unique()

relevant.orders <- relevant.orders$order_name[!is.na(relevant.orders$order_name)]

#The same check is done at the family level. 
family.check <- filtered.data.relevant %>% group_by(family_name, bin_uri) %>% tally()
family.habitat <- dplyr::inner_join(family.check, hab.type.per.bin, by = "bin_uri")

#Check for families where there are 3 or more BINS for each habitat (Freshwater and Marine)

relevant.families <- family.habitat %>% 
  group_by(family_name, habitat.final) %>% 
  mutate(myfamily = n()) %>% filter(myfamily > bin.number) %>% distinct(family_name) %>% ungroup(habitat.final) %>% mutate(familycount = n()) %>% filter(familycount > 1) %>% ungroup(family_name) %>% dplyr::select(family_name) %>% unique()

relevant.families <- relevant.families$family_name[!is.na(relevant.families$family_name)]


#If there are taxonomic groups (whether class, order, or family) meeting the sample size critera, split datasets by the rank.

if (length(relevant.families > 0)) {
  
  #Split by family if sample size criteria is met.
  family.datasets <- filtered.records3[filtered.records3$family_name %in% relevant.families,]
  data.sets <- split(family.datasets, family.datasets$family_name)
  
} else if (length(relevant.orders > 0)) {
  
  #Split by order if sample size criteria is met.
  order.datasets <- filtered.records3[filtered.records3$order_name %in% relevant.orders,]
  data.sets <- split(order.datasets, order.datasets$order_name)
  
} else {
  
  #Split by class (use the whole data set in the analysis)
  data.sets <- split(filtered.records3, filtered.records3$class_name)
    
}

#Save list of data sets if required.
#saveRDS(data.sets, "~/Desktop/RA_Guelph/Project1/datasetslistBranchio.RData")



###
#Extra: Sample 100 records to manually check if habitat assignments are correct.

#Obtain records with a freshwater or marine designation only.
freshwater <- filtered.records2 %>% filter(habitat.final == "Freshwater")
marines <- filtered.records2 %>% filter(habitat.final == "Marine")

#Combine freshwater and marine records together.
all.fresh.marine <- rbind(freshwater,marines)

#Set seed and randomly sample 100 records.
set.seed(100)

habitatcheck <- data.table(all.fresh.marine)
habitatcheck <- habitatcheck[sample(.N, 100)]

#Obtain only relevant columns to make the check easier.
habitatcheck <- habitatcheck[,c("recordID","bin_uri","phylum_name","class_name","order_name","family_name","genus_name","species_name","scientificName", "taxonID.x", "taxonID.y", "habitat.worms.species","habitat.worms.genus","lat","lon","land","habitat.type.gps","habitat.region","habitat.type.habreg","habitat.final")]

#Write data frame to tsv file to check outside of R. Add a new column called Check and place a 1 for records with the correct habitat designation and 0 for those with an incorrect designation.
#write_tsv(habitatcheck, "~/Desktop/RA_Guelph/Project1/habitatcheck.tsv")

#After checking manually, read in the checked 100 records and observe which records received an incorrect designation.
#habitat.checked <- read_tsv("habitatcheck.tsv")
#habitat.wrong <- habitat.checked %>% filter(Check == 0)

###

```


```{r DNA sequence quality check and sequence alignment, results = 'hide', message=FALSE, warning=FALSE}

#In this section, we checked for likely stop codons and indels in the data sets. Records with sequences containing a likely stop codon and/or indel were removed and the remaining records were aligned using the aligner function in the DECIPHER library.

#1. DNA sequence stop codon and indel check using Coil.

#Function to run coil pipeline on data sets.

coil.function <- function(data.set) {
  
  #Input: data frame for a taxonomic group.
  #Output: data frame with framed sequences for a taxonomic group, excluding records with a likely stop codon or indel. 
  
  #Obtain relevant columns from data set.
  barcode_data_coil <- data.sets[[1]] %>% dplyr::select(recordID, processid, bin_uri,nucleotides2, habitat.final.y, class_name, order_name, family_name)

  #Obtain genetic codes for the taxonomic groups (for translation). 
  genetic_codes <- lapply(barcode_data_coil$class_name, which_trans_table)
  genetic_codes <- unlist(genetic_codes)

  #Add column containing the genetic codes and convert nucleotides and recordIDs to character type.
  barcode_data_coil$genetic_code <- genetic_codes
  barcode_data_coil$nucleotides <- as.character(barcode_data_coil$nucleotides2)
  barcode_data_coil$recordID <- as.character(barcode_data_coil$recordID)

  #Determine the number of cores on system to speed up next step.
  numCores <- detectCores()

  #Run coil pipeline on all sequences to frame them and find likely stop codons and indels.
  barcode_data_coil$coi_output = mclapply(1:length(barcode_data_coil$recordID), function(i){
    coi5p_pipe(barcode_data_coil$nucleotides[i], 
              name = barcode_data_coil$recordID[i], 
              trans_table = barcode_data_coil$genetic_code[i], triple_translate = TRUE)
  }, mc.cores = numCores)

  #Save coil output if needed.
  #saveRDS(barcode_data_coil, "barcode_data_coil.RData")

  #Add column stating whether a stop codon is present or not for each sequence.
  foreach(i=1:nrow(barcode_data_coil)) %do% {
    
    stopcodon <- barcode_data_coil$coi_output[[i]]$stop_codons
    barcode_data_coil$stopcodons[i] <- stopcodon[1]
  }

  #Add column stating whether an indel is present for each sequence.
  foreach(i=1:nrow(barcode_data_coil)) %do% {
    
    indels <- barcode_data_coil$coi_output[[i]]$indel_likely
    barcode_data_coil$indels[i] <- indels[1]
  }

  #Check how many sequences have a stop codon.
  sum(barcode_data_coil$stopcodons)

  #Obtain rows of sequences with a stop codon.
  stop_indices <- which(barcode_data_coil$stopcodons == TRUE)
  
  #Filter out sequences with a stop codon if present.
  if (length(stop_indices) > 0) {
    
    barcode_data_coil_filtered <- barcode_data_coil[-stop_indices,]

  } else {
    
    barcode_data_coil_filtered <- barcode_data_coil
  }

  #Check how many sequences have indels.
  sum(barcode_data_coil_filtered$indels)

  #Obtain rows of sequences with a stop codon.
  indel_indices <- which(barcode_data_coil_filtered$indels == TRUE)

  #Filter out sequences with indels if present. 
  if (length(indel_indices) > 0) {
    
    barcode_data_coil_filtered <- barcode_data_coil_filtered[-indel_indices,]
    
  } 
  
  #Place framed sequences in new column. 
  foreach(i=1:nrow(barcode_data_coil_filtered)) %do% {
    
    framedseq <- barcode_data_coil_filtered$coi_output[[i]]$framed
    barcode_data_coil_filtered$framedseqs[i] <- framedseq[1]
  }

  barcode_data_coil_filtered <<- barcode_data_coil_filtered
  
  return(barcode_data_coil_filtered)

}

#Run coil function on list of data sets. A list of filtered data sets of the same length will be returned.

barcode_data_coil_filtered_sets <- lapply(data.sets, coil.function)


#saveRDS(barcode_data_coil_filtered_sets, "barcode_data_coil_filtered_setBranchio.RData")


#Re-check sample size criteria since some records may have been removed.

#Count BINs with both habitat designations and 5 or more sequences per BIN
sample.check <- lapply(barcode_data_coil_filtered_sets, function(x) as.data.frame(x) %>% group_by(bin_uri, habitat.final.y) %>% filter(habitat.final.y != "na") %>% tally() %>% filter(n > 4))

#saveRDS(sample.check, "samplecheckBranchio.RData")

#Alignment function.

alignment.function <- function(barcode_data_coil_filtered) {

  #Input: filtered data frame for taxonomic group
  #Output: aligned sequences for taxonomic group
  
  #Convert sequences to a suitable format for alignment with the DECIPHER library. Use recordID as sequence name. Note that the alignment may result in reordering of the sequences.
  names(barcode_data_coil_filtered$framedseqs) <- barcode_data_coil_filtered$recordID

  stringsetseqs <- DNAStringSet(barcode_data_coil_filtered$framedseqs)
  names(stringsetseqs)
  
  #Remove any gaps present in sequences.
  stringsetseqs <- RemoveGaps(stringsetseqs, removeGaps = "all")
  
  #Align sequences using default settings.
  COI.alignment <<- AlignSeqs(stringsetseqs)
  
  #Write alignment to file if needed. 
  #writeXStringSet(COI.alignment, file = "COI.alignment.fas", format = "fasta")
  
  return(COI.alignment)
  
}

#Execute alignment function on list of data sets containing framed sequences. 
COI.alignments <- lapply(barcode_data_coil_filtered_sets, alignment.function)

#Save list of alignments if needed.
#saveRDS(COI.alignments, "COIalignmentsBranchio.RData")

```


```{r Clustering}

#In this section, sequences are clustered, silhouette indices are computed, and results/figures are compiled.

#Read in list of alignments, filtered data sets, and sample size criteria, if not in environment.----

COI.alignments <- readRDS("COIalignmentsActino.Rdata")
barcode_data_coil_filtered_sets <- readRDS("barcode_data_coil_filtered_setActino.Rdata")
sample.check <- readRDS("samplecheckActino.Rdata")

#Create clustering function to cluster sequences in each taxonomic group in the list of data sets.----

cluster.function <- function(COI.alignment) {
  
  #Input: sequence alignment object.
  #Output: clustering results (includes each record's silhouette index and cluster number).
  
  #Convert alignment data to DNA Bin class using function from ape package.
  dnaBin.COI <- as.DNAbin(COI.alignment)
  class(dnaBin.COI)

  #Create distance matrix. 
  distanceMatrix <- dist.dna(dnaBin.COI, model = chosen.model, as.matrix = TRUE, pairwise.deletion = TRUE)

  #Cluster using IdClusters function with previously defined parameters.
  clusters.COI <<- IdClusters(distanceMatrix,
                                   method = clustering.method,
                                   cutoff = clustering.threshold,
                                   showPlot = TRUE,
                                   type = "both",
                                   verbose = TRUE)

  #Unlist clustering result to obtain data frame of results.
  #clusters <- unlist(clusters.COI[[1]])
  
  #Check number of unique clusters.
  length(unique(unlist(clusters.COI[[1]][1])))

  #Unlist clustering results to obtain data frame of results.
  cluster.assigned <<- unlist(clusters.COI[[1]], use.names = FALSE)

  #Function to convert NA's to '0'
  na.zero <- function (x) {
      x[is.na(x)] <- 0
      return(x)
    }
  
  #Applying the na.zero function on the distance matrix.
  distance_mat <<- na.zero(distanceMatrix)

  ##Obtain silhouette indices.

  #Calculate the silhouette indices - metric which explains how similar an object is to its own cluster when compared to other clusters. Ranges from -1 to +1.
  sil <<- silhouette(cluster.assigned,distance_mat)
  
  #Summary of the Silhouette index
  summary(sil)[2]

  #Average Silhouette value.
  avg.sil.val <- summary(sil)[[4]]
  
  #Plot the silhouette values.
  silplot <- plot(sil, border=NA)

  #For an elegant visualization use the fviz_silhouette function. 
  sil.data.plot <<- fviz_silhouette(sil)
  sil.data <- sil.data.plot$data

  #Combine assigned clusters and record IDs.
  cluster.name <- cbind("cluster" = cluster.assigned, "recordID" = colnames(distance_mat), "name" = c(1:length(cluster.assigned)))
  
  cluster.name <- as.data.frame(cluster.name)

  #Combine cluster information with silhouette indices.
  cluster.name.sil <<- dplyr::inner_join(cluster.name, sil.data, by = "name")
  
  return(cluster.name.sil)
  #return(clusters.COI)
}

#Execute cluster function on list of sequence alignments.
clusters <- lapply(COI.alignments, cluster.function)

#Create merge function to combine cluster data with original data sets by recordIDs.----

#Inititate empty list to include merged data frames.
cluster.habitats <- list()

merge.function <- function(barcode_data_coil_filtered_sets, clusters) {
  
  #Input: list of filtered data frames and list of clustering results data frames.
  #Output: list of merged data sets containing recordIDs, habitat information, cluster numbers, and silhouette indices.
  
  #Iterate through list of filtered data frames and combine with clustering results.
  for (i in 1:length(barcode_data_coil_filtered_sets)) {
  
    cluster.habitat <- dplyr::left_join(barcode_data_coil_filtered_sets[[i]], clusters[[i]], by = "recordID")
    
    #Assign merged data frame to list. 
    cluster.habitats[[i]] <- cluster.habitat
  
  }
  
  #Return list.
  return(cluster.habitats)
}

#Execute merge function on list of filtered data sets and list of clustering results.
cluster.habitats <- merge.function(barcode_data_coil_filtered_sets, clusters)

#Save list of merged results.
#saveRDS(cluster.habitats, "clusterhabitatsMalaco.RData")

#Create function to produce colored dendrograms.----

#Try to color dendrogram according to freshwater and marine.

#Initiate list to input colored dendrograms.
colored.dends <- list()

#Obtain group names.
groupnames <- names(clusters)

color.dendrogram <- function(clusterhabitats, clusters, groupnames) {
  
  #Input: cluster.habitats, COI cluster objects, and cluster names.
  #Output: colored dendrograms
  
  #Loop through list of data sets.
  for (i in 1:length(clusterhabitats)){
    
    #Subset the dendrogram object.
    dend <- clusters[[i]][[2]]

    #Get dendrogram labels.
    labels <- dend %>% labels()
    labels <- data.frame("recordID" = labels)

    #Get habitat for record IDs (labels)
    habitat.records <- data.frame("recordID" = clusterhabitats[[i]]$recordID, "habitat" = clusterhabitats[[i]]$habitat.final.y)

    habitat.records2 <- dplyr::left_join(labels, habitat.records, by = "recordID")

    #Assign col_GROUP.
    col_GROUP <- habitat.records2$habitat
    
    #Change dendrogram labels to I's (so only a horizontal colored line is observed; less cluttered)
    dend <- dend %>% set("labels", "I")

    #Sort col_GROUP color palette according to habitats: Turqouise for Marine, Magenta for Freshwater, and Gray for na.
    col_GROUP[col_GROUP == "Marine"] <- "#00CED1"
    col_GROUP[col_GROUP == "Freshwater"] <- "#ff00ff"
    col_GROUP[col_GROUP == "na"] <- "#CCCCCC"
  
    #Check dendrogram labels and colors.
    dend %>% labels()
    dend %>% labels_colors()
    
    #Color branch tips according to habitat type.
    dend2 <- assign_values_to_leaves_edgePar(dend=dend, value = col_GROUP, edgePar = "col")
    dend3 <- dend2 %>% set("labels_colors",col_GROUP)
    
    dend4 <- dend3 %>% plot(main = paste("Dendrogram for ",groupnames[[i]], sep = ""))
    
    #Store dendrogram plot in initiated list.
    colored.dends[[i]] <- dend3
    
  }
  
  #Return list of colored dendrograms.
  return(colored.dends)
}

#Execute the color.dendrogram clusters on all the data sets.
coldends <- color.dendrogram(cluster.habitats, clusters, groupnames)

#Obtain plot for Onychopoda.
coldends[[1]] %>% plot(main = "Dendrogram for Onychopoda")


#Create function to re-filter data according to sample size criteria.----

#Initiate empty list to append filtered data sets meeting the sample size criteria.
cluster.habitats.relevant <- list()

samplecheck.function <- function(cluster.habitats, sample.check) {
  
  #Input: list of clustering results with habitat information and list of sample size critera for each taxonomic group.
  #Output: list of clustering results with habitat information meeting sample size criteria.
  
  #Iterate over list of clustering results with habitat information.
  for (i in 1:length(cluster.habitats)) {
  
    #Include only BINs that meet the sample size criteria set earlier.
    cluster.habitat.relevant <- cluster.habitats[[i]][cluster.habitats[[i]]$bin_uri %in% sample.check[[i]]$bin_uri,]
    
    #Assign new data frames to empty list created earlier.
    cluster.habitats.relevant[[i]] <- cluster.habitat.relevant
  
  }
  
  #Return list of relevant data sets meeting sample size criteria.
  return(cluster.habitats.relevant)
}

#Execute function on the two lists of data frames cluster.habitats and sample.check.
cluster.habitats.relevant <- samplecheck.function(cluster.habitats, sample.check)

#Save list of data sets that will be used in statistical analyses downstream, if needed.
#saveRDS(cluster.habitats.relevant, "clusterhabitatsrelevantMalaco.Rdata")

#cluster.habitats.relevant <- readRDS("clusterhabitatsrelevantActino.Rdata")


#t-test function----
#Determine the mean silhouette index value for freshwater and marine clusters and, using a t-test, determine if there is a statistically significant difference across the two groups.

#Create function to run t-test analysis.
t.test.sil <- function(cluster.habitat.relevant) {
  
  #Input: clustering results meeting sample size criteria
  #Output: t-test results
  
  #Obtain counts of records grouped by clusters and habitats. 
  cluster.habitat.relevant2 <- cluster.habitat.relevant %>% group_by(cluster.y, habitat.final.y) %>% mutate(count1 = n())
  
  #Obtain counts of records grouped by clusters only.
  cluster.habitat.relevant2 <- cluster.habitat.relevant2 %>% group_by(cluster.y) %>% mutate(count2 = n())
  
  #Remove clusters containing one record.
  cluster.habitat.relevant2 <- cluster.habitat.relevant2 %>% filter(count2 != 1)
  
  #Select for clusters that have one habitat type (either freshwater or marine).
  cluster.habitat.relevant2 <- cluster.habitat.relevant2 %>% filter(count1 == count2)
  
  #Obtain the mean silhouette index value for each cluster.
  cluster.habitat.relevant2 <- cluster.habitat.relevant2 %>% group_by(cluster.y) %>% mutate(mean.sil = mean(sil_width))
  
  #Select the mean silhouette indices for freshwater clusters only.
  fresh.sil <- cluster.habitat.relevant2 %>% filter(habitat.final.y == "Freshwater")
  uniqfreshsil <- fresh.sil[!duplicated(fresh.sil$cluster.y), ]
  fresh.sils <- unique(uniqfreshsil$mean.sil)
  
  #Select the mean silhouette indices for marine clusters only.
  marine.sil <- cluster.habitat.relevant2 %>% filter(habitat.final.y == "Marine")
  uniqmarinesil <- marine.sil[!duplicated(marine.sil$cluster.y), ]
  marine.sils <- unique(uniqmarinesil$mean.sil)

  #Run t test to determine whether there is a significant difference between marine and freshwater silhouette indices.
  t.test.result <- t.test(fresh.sils, marine.sils)
  
  #Obtain t-test results, freshwater and marine silhouette indices, and recordIDs for freshwater and marine records (to obtain length).
  t.test.result.values <- list(t.test.result, fresh.sils, marine.sils, fresh.sil$recordID, marine.sil$recordID)
  
  return(t.test.result.values)
  
}

#Execute t-test function on data sets.
t.test.results <- lapply(cluster.habitats.relevant, t.test.sil)

#Obtain average silhouette indicies from results for freshwater and marine clusters.
fresh.sils <- sapply(t.test.results, "[[", 2)
marine.sils <- sapply(t.test.results, "[[", 3)

#Obtain freshwater and marine records data sets (we will use these to count how many freshwater and marine records were used in the analysis).
fresh.sil <- sapply(t.test.results,"[[", 4)
marine.sil <- sapply(t.test.results,"[[", 5)

####Violin plots to observe range of freshwater and marine silhouette values----

#Read in clustering results meeting sample size criteria for each group.

chr.Actino <- readRDS("clusterhabitatsrelevantActino.Rdata")
chr.Bivalvia <- readRDS("clusterhabitatsrelevantBivalvia.Rdata")
chr.Branchio <- readRDS("clusterhabitatsrelevantBranchio.Rdata")
chr.Malaco <- readRDS("clusterhabitatsrelevantMalaco.Rdata")

#Obtain family/order names.
actino.names <- unique(unlist(sapply(chr.Actino, "[[", 8)))
biv.names <- unique(sapply(chr.Bivalvia, "[[", 8))[1]
branchio.names <- unique(sapply(chr.Branchio, "[[", 7))[1]
malaco.names <- unique(unlist(sapply(chr.Malaco, "[[", 8)))

#Assign names to clustering results.
names(chr.Actino) <- actino.names
names(chr.Bivalvia) <- biv.names
names(chr.Branchio) <- branchio.names
names(chr.Malaco) <- malaco.names

#Combine all groups into one list.
chr.all <- c(chr.Actino, chr.Bivalvia, chr.Branchio, chr.Malaco)

#Run t.test function to obtain freshwater and marine silhouette values.
t.test.results.violin <- lapply(chr.all, t.test.sil)

#Obtain average silhouette indicies from results for freshwater and marine clusters.
fresh.sils.violin <- sapply(t.test.results.violin, "[[", 2)
marine.sils.violin <- sapply(t.test.results.violin, "[[", 3)

#Freshwater distribution.
fresh.sils.violin.df <- sapply(fresh.sils.violin, '[', seq(max(sapply(fresh.sils.violin, length))))
fresh.sils.violin.df <- as.data.frame(fresh.sils.violin.df)
df.long.fresh <- pivot_longer(fresh.sils.violin.df, cols=1:18, names_to = "Taxa", values_to = "Sil.values")
df.long.fresh$Type <- c(rep("Freshwater",length(df.long.fresh$Taxa)))


#Marine distribution.
marine.sils.violin.df <- sapply(marine.sils.violin, '[', seq(max(sapply(marine.sils.violin, length))))
marine.sils.violin.df <- as.data.frame(marine.sils.violin.df)
df.long.marine <- pivot_longer(marine.sils.violin.df, cols=1:18, names_to = "Taxa", values_to = "Sil.values")
df.long.marine$Type <- c(rep("Marine", length(df.long.marine$Taxa)))

#Combine freshwater and marine distributions.
df.long <- rbind(df.long.fresh, df.long.marine)

#Assign group colors (magenta for freshwater and turqouise for marine)
group.colors <- c(Freshwater = "#ff00ff", Marine = "#00CED1")

#Assign x-axis label colors to represent taxonomic classes.
label.colors <- c(rep("#AA4499",7),"#44AA99", "#999933",rep("#6699CC",9))

#Plot individual dsitributions
ggplot(df.long.fresh, aes(x=factor(Taxa, levels=unique(Taxa)), y=Sil.values, color = Type)) + geom_violin() + theme(axis.text.x = element_text(angle = 60, vjust = 0.5, hjust=0.5, colour = label.colors), plot.title = element_text(hjust = 0.5)) + xlab("Taxa") + ylab("Silhouette Values") + ggtitle(" Distribution of Freshwater Silhouette Values") + scale_colour_manual(values=group.colors)

ggplot(df.long.marine, aes(x=factor(Taxa, levels=unique(Taxa)), y=Sil.values, color = Type)) + geom_violin() + theme(axis.text.x = element_text(angle = 60, vjust = 0.5, hjust=0.5, colour = label.colors), plot.title = element_text(hjust = 0.5)) + xlab("Taxa") + ylab("Silhouette Values") + ggtitle(" Distribution of Marine Silhouette Values") + scale_colour_manual(values=group.colors)

#Plot combined distributions.
ggplot(df.long, aes(x=factor(Taxa, levels=unique(Taxa)), y=Sil.values, color = Type)) + geom_violin() + theme(axis.text.x = element_text(angle = 60, vjust = 0.9, hjust=0.9, colour = label.colors), plot.title = element_text(hjust = 0.5), legend.position = "None") + xlab("Taxa") + ylab("Silhouette Values") + ggtitle(" Distribution of Silhouette Values") + scale_colour_manual(values=group.colors) + facet_grid(. ~ Type, scales = "free_y")

#Box plot to observe outliers.
boxplotgraph <- ggplot(df.long, aes(x=factor(Taxa, levels=unique(Taxa)), y=Sil.values, color = Type)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 60, vjust = 0.9, hjust=0.9, colour = label.colors), plot.title = element_text(hjust = 0.5)) + xlab("Taxa") + ylab("Silhouette Values") + ggtitle(" Distribution of Silhouette Values") + scale_colour_manual(values=group.colors) + facet_grid(. ~ Type)

####Check for outliers using boxplot.stats function----

#Check for number of clusters with average silhouette values.
sum(!is.na(df.long$Sil.values))

#Determine which cluster silhouette values are outliers, overall.
outliers <- boxplot.stats(df.long$Sil.values)$out
out.ind <- which(df.long$Sil.values %in% c(outliers))
out.ind

df.long.outliers <- df.long[out.ind,]

#Obtain number of taxa with outlier clusters.
table(df.long.outliers$Taxa)

outliers2 <- boxplot.stats(df.long.outliers$Sil.values)$out
out.ind2 <- which(df.long.outliers$Sil.values %in% c(outliers2))

df.long.outliers2 <- df.long.outliers[out.ind2,]


####Histograms of silhouette values----

#Plot freshwater and marine silhouette indices as a histogram by taxonomic group.

#Obtain Silhouette indices for each sequence (Mysidae family).
freshsil <- data.frame(fresh.sils[[7]])
names(freshsil) <- "Cluster.sil.index"
marinesil <- data.frame(marine.sils[[7]])
names(marinesil) <- "Cluster.sil.index"

#Combine marine and freshwater values.
combined.fresh.marine <- rbind(freshsil,marinesil)
combined.fresh.marine$type <- c(rep("Freshwater",length(freshsil$Cluster.sil.index)), rep("Marine",length(marinesil$Cluster.sil.index)))

#Plot histogram and color by habitat type.
ggplot(combined.fresh.marine, aes(x=Cluster.sil.index, fill = type)) + geom_histogram(alpha=0.5) + ggtitle("Mysidae Family") + theme(legend.text=element_text(size=10))

#Find number of freshwater and marine values.
combined.fresh.marine %>% filter(type == "Freshwater") %>% nrow()
combined.fresh.marine %>% filter(type == "Marine") %>% nrow()


####Function to combine relevant statistical results----

#Initiate empty list for statistical results.
stat.data <- list()

stat.extract <- function(clusterdata, ttestresult) {
  
  #Input: clustering results meeting sample size criteria and t-test results.
  #Output: data frame of statistical results.
  
  #Iterate over clustering results.
  for(i in 1:length(clusterdata)) {
    
    #Obtain name of taxonomic group, number of unique bins, t-test freshwater mean estimate, t-test marine mean estimate, and t-test p-value. 
    tax.name <- unique(clusterdata[[i]]$family_name)
    uniqbins <- length(unique(clusterdata[[i]]$bin_uri))

    ttest.fresh.est <- ttestresult[[i]]$estimate[[1]]
    ttest.marine.est <- ttestresult[[i]]$estimate[[2]]
    ttest.pval <- ttestresult[[i]]$p.value
  
    #Place results into data frame.
    stat.data[[i]] <- data.frame("Taxon" = tax.name, "No.of.bins" = uniqbins, "Fresh.av.sil" = ttest.fresh.est, "Marine.av.sil" = ttest.marine.est, "t.test.p.values" = ttest.pval)
  }
  
  #Return list of statistical results.
  return(stat.data)
}

#Execute function to obtain results cohesively. 
statoutputs <- stat.extract(cluster.habitats.relevant, t.test.results)
statoutputs <- do.call("rbind",statoutputs)

#Add number of freshwater clusters to results.
statoutputs$Fresh.clust <- sapply(fresh.sils, length)

#Use below code for Branchiopoda and Bivalvia group (or any group with one taxa in the list).
#statoutputs$Fresh.clust <- length(fresh.sils)

#Add number of marine clusters to results.
statoutputs$Marine.clust <- sapply(marine.sils, length)

#Use below code for Branchiopoda and Bivalvia group.
#statoutputs$Marine.clust <- length(marine.sils)

#Add number of records in freshwater and marine clusters to results.
statoutputs$Fresh.records <- sapply(fresh.sil, length)
statoutputs$Marine.records <- sapply(marine.sil, length)

#Use below code for Branchiopoda and Bivalvia group.
#statoutputs$Fresh.records <- length(fresh.sil)
#statoutputs$Marine.records <- length(marine.sil)

#Find difference between freshwater and marine silhouette means and add to results.
statoutputs$Difference <- (statoutputs$Fresh.av.sil - statoutputs$Marine.av.sil)

#Re-order columns in results data frame.
statoutputs <- statoutputs[,c(1,2,6,7,8,9,3,4,10,5)]


####Formattable tables----

#Creating visually appealing table using formattable library.

#Set colors.
customGreen0 = "#DeF7E9"
customGreen = "#71CA97"
customRed = "#ff7f7f"
customYellow = "#FF9900"

#Set colors for difference values. For differences between freshwater and marine silhouette means, if the freshwater silhouette mean is higher than the marine silhouette mean, the difference value will be green with an upwards arrow next to it. Otherwise, the value is red with a downwards arrow.
difference_formatter <- formatter("span",style = x ~ style(font.weight = "bold", color = ifelse(x > 0, customGreen, ifelse(x < 0, customRed, "black"))), x ~ icontext(ifelse(x>0, "arrow-up", "arrow-down"), x))

#Highlight significant p values in yellow.
pvalue_formatter <- formatter("span",style = x ~ style(font.weight = "bold", color = ifelse(x < 0.05, customYellow, ifelse(x < 0.05, customYellow, "black")), x))

#Create table using formattable library. 
form.table <- formattable(statoutputs, list(`Taxon` = formatter(
              "span", style = ~ style(color = "grey",font.weight = "bold")), `Fresh.av.sil`= color_tile(customGreen0, customGreen),
  `Marine.av.sil`= color_tile(customGreen0, customGreen), `Difference` = difference_formatter, `t.test.p.values` = pvalue_formatter))

#Round all values in the table to 3 digits.
form.table$Fresh.av.sil <- round(form.table$Fresh.av.sil, 3)
form.table$Marine.av.sil	<- round(form.table$Marine.av.sil, 3)
form.table$Difference	<- round(form.table$Difference, 3)
form.table$t.test.p.values <- round(form.table$t.test.p.values, 3)

form.table
#Save results.
#saveRDS(form.table, "MalacoCompTableResults.RData")

#Read in all results across taxonomic classes.

#Read in Malacostraca results and add row above families (so the name malacostraca is present).
form.table1 <- readRDS("MalacoTableResults.RData")
malacovector <- c("Malacostraca", rep(NA,9))
form.table1 <- rbind(malacovector, form.table1)
form.table1[is.na(form.table1)] = ''

#Read in Actinopterygii results and add row above families.
form.table2 <- readRDS("ActinoTableResults.RData")
actinovector <- c("Actinopterygii", rep(NA,9))
form.table2 <- rbind(actinovector, form.table2)
form.table2[is.na(form.table2)] = ''

#Read in Branchiopoda results
form.table3 <- readRDS("BranchioTableResults.RData")
branchiovector <- c("Branchiopoda", rep(NA,9))
form.table3 <- rbind(branchiovector, form.table3)
form.table3[is.na(form.table3)] = ''

#Read in Bivalvia results.
form.table4 <- readRDS("BivalviaTableResults.RData")
bivalviavector <- c("Bivalvia", rep(NA,9))
form.table4 <- rbind(bivalviavector, form.table4)
form.table4[is.na(form.table4)] = ''

#Combine results tables.
form.tableall <- rbind(form.table2,form.table4,form.table3,form.table1)

#Set difference formatter.
difference_formatter <- formatter("span",style = x ~ style(font.weight = "bold", color = ifelse(x > 0, customGreen, ifelse(x < 0, customRed, "black"))), x ~ icontext(ifelse(x>0, "arrow-up", "arrow-down"), x))

#Set taxon formatter to change font and color of taxa column.
taxon_formatter <- formatter("span", style = x ~ style(font.weight = "bold", color = ifelse(x %in% c("Malacostraca","Actinopterygii","Bivalvia","Branchiopoda"),"black", "grey"), x))

#Highlight significant p values in yellow.
pvalue_formatter <- formatter("span",style = x ~ style(font.weight = "bold", color = ifelse(x < 0.05, customYellow, ifelse(x < 0.05, customYellow, "black")), x))

#Create table for all taxa using formattable library. 
form.tableall <- formattable(form.tableall, list(`Taxon` = taxon_formatter, `Fresh.av.sil`= color_tile(customGreen0, customGreen),
  `Marine.av.sil`= color_tile(customGreen0, customGreen), `Difference` = difference_formatter, `t.test.p.values` = pvalue_formatter))

####Master t-test and adjusted p-values----

#Run master paired t-test for all taxonomic groups involved.

#Read in table results for all taxonomic classes again (we need them without the formatting).

form.table1 <- readRDS("MalacoTableResults.RData")
form.table2 <- readRDS("ActinoTableResults.RData")
form.table3 <- readRDS("BranchioTableResults.RData")
form.table4 <- readRDS("BivalviaTableResults.RData")

#Combine results tables.
form.tableall <- rbind(form.table2,form.table4,form.table3,form.table1)

resultstable <- form.tableall

#Execute t-test to determine whether there is a significant difference between overall marine and freshwater silhouette indices.
master.t.test.result <- t.test(resultstable$Fresh.av.sil, resultstable$Marine.av.sil, paired = TRUE)
master.t.test.result

#Find mean freshwater and silhouette overall.
mean(resultstable$Fresh.av.sil)
mean(resultstable$Marine.av.sil)

#Adjusted p-values according to Benjamini & Hochberg method for taxon-specific t-tests.
adjusted.p <- p.adjust(form.table$t.test.p.values, method = "BH")
adjusted.p

#Check if previously significant p-values are still below 0.05
adjusted.p[10]
adjusted.p[15]

#For clustering threshold of 0.03.
#adjusted.p <- p.adjust(form.table$t.test.p.values, method = "BH")
#adjusted.p

#adjusted.p[2]
#adjusted.p[9]
#adjusted.p[15]

####Dumbell plots----

#Dumbell plots for freshwater vs marine sils.

form.table <- form.tableall

#Subset freshwater silhouette values.
dumbbellplotdatafresh <- form.table[,c("Taxon", "Fresh.av.sil")]
colnames(dumbbellplotdatafresh) <- c("Taxon", "Av.sil.value")

#Subset marine silhouette values.
dumbbellplotdatamarine <- form.table[,c("Taxon","Marine.av.sil")]
colnames(dumbbellplotdatamarine) <- c("Taxon", "Av.sil.value")

#Combine freshwater and marine silhouette values.
dumbbellplotdata <- rbind(dumbbellplotdatafresh, dumbbellplotdatamarine)

#Define length to repeat "Marine" and "Freshwater". This will help color the plot points by habitat.
replength <- length(form.table$Taxon)

#Add habitat type to each row.
groupvector <- c(rep("Freshwater", replength), rep("Marine", replength))
dumbbellplotdata$Type <- groupvector

#Add a number for each unique family (to pair points in plot).
grouppair <- c(rep(c(1:18),2))
dumbbellplotdata$pair <- grouppair

#Add colors and shapes to data points. Magenta triangles for freshwater and Turquoise circles for marine.
group.colors <- c(Freshwater = "#ff00ff", Marine = "#00CED1")
group.shapes <- c(Freshwater = 17, Marine = 16)

#Assign x-axis label colors to represent taxonomic classes.
label.colors <- c(rep("#AA4499",7),"#44AA99", "#999933",rep("#6699CC",9))

#Plot dumbbell plot using ggplot.
ggplot(dumbbellplotdata, aes(x= factor(dumbbellplotdata$Taxon, levels=unique(dumbbellplotdata$Taxon)), y=Av.sil.value)) + geom_line(aes(group = pair)) + geom_point(aes(color=Type, shape = Type), size = 4) + theme(axis.text.x = element_text(angle = 60, vjust = 0.7, hjust=  0.7, colour = label.colors),plot.title = element_text(hjust = 0.5)) + xlab("Taxon") + ylab("Average Silhouette Value") + scale_colour_manual(values=group.colors) + scale_shape_manual(values = group.shapes) + ggtitle("Freshwater vs. Marine Silhouette Values") + labs(fill = "Habitat Type")


####Extra statistics----

#Obtain number of bins and clusters.

totalbins <- sum(statoutputs$No.of.bins)
totalclust <- sum(statoutputs$No.of.clusters)

#Obtain total number of records

freshtotal <- sum(statoutputs$Fresh.records)
marinetotal <- sum(statoutputs$Marine.records)
totalrecords <- sum(freshtotal+ marinetotal)

#Records after coil filtering step.

records.after.coil <- sapply(barcode_data_coil_filtered_sets, nrow)
records.after.coil <- sum(records.after.coil)

#Save statistical results, if needed.
#write_csv(statoutputs, "statoutputs.csv")

####Silhouette plots for different families:----


#Obtain freshwater clusters for families of interest.
freshclusters <- cluster.habitats.relevant[[6]] %>% filter(habitat.final.y == "Freshwater")
uniqfresh <- unique(freshclusters$cluster.x)

#Re-run clustering for family of interest to obtain silhouette values.
lapply(COI.alignments[6], cluster.function)
sil2 <- fviz_silhouette(sil)
sil2
sil2 <- sil2$data %>% filter(cluster %in% uniqfresh)

#Plot freshwater silhouette values for family of interest.
ggplot(sil2) + geom_col(aes(x=name, y = sil_width, color = cluster,group = cluster)) + xlab("Sequence records") + ylab("Silhouette Width") + theme(axis.text.x=element_blank(), plot.title = element_text(hjust = 0.5)) + ggtitle("Freshwater Silhouette Plot")

#Obtain marine clusters for family of interest.
marineclusters <- cluster.habitats.relevant[[6]] %>% filter(habitat.final.y == "Marine")
uniqmarine <- unique(marineclusters$cluster.x)
sil3 <- fviz_silhouette(sil)
sil3 <- sil3$data %>% filter(cluster %in% uniqmarine)

#Plot marine silhouette values for family of interest.
ggplot(sil3) + geom_col(aes(x=name, y = sil_width, color = cluster,group = cluster)) + xlab("Sequence records") + ylab("Silhouette Width") + theme(axis.text.x=element_blank(), plot.title = element_text(hjust = 0.5)) + ggtitle("Marine Silhouette Plot")

####Linear Model----

#Linear model to check trends between number of records and silhouette values.

#Organize data by habitat groups.
names(form.table)
form.table$group1 <- c(rep("Actinopterygii", 7),"Bivalvia","Branchiopoda",rep("Malacostraca", 9))
records.sils.fresh <- form.table[,c("Fresh.records","Fresh.av.sil", "group1")]
records.sils.marine <- form.table[,c("Marine.records","Marine.av.sil", "group1")]

names(records.sils.fresh) <- c("record.number","av.sil", "Taxonomic.class")
names(records.sils.marine) <- c("record.number","av.sil", "Taxonomic.class")

#Combine freshwater and marine values.
records.sils <- rbind(records.sils.fresh,records.sils.marine)

#Add habitat type to each row.
replength <- length(form.table$Taxon)
groupvector <- c(rep("Freshwater", replength), rep("Marine", replength))

records.sils$habtype <- groupvector

#Execute linear regression model. Average silhoutte values (dependent variable) vs Number of records (independent variable)
model.1 <- lm(av.sil[1:18] ~ record.number[1:18], records.sils)
model.2 <- lm(av.sil ~ habtype, records.sils)

summary(model.1)
summary(model.2)

#Set label colors
label.colors <- c(rep("Actinopterygii",7),"Bivalvia", "Branchiopoda",rep("Malacostraca",9),rep("Actinopterygii",7),"Bivalvia", "Branchiopoda",rep("Malacostraca",9))

label.colors <- c(Actinopterygii = "#AA4499",Bivalvia = "#44AA99",Branchiopoda ="#999933", Malacostraca = "#6699CC")

#Obtain values to plot (first 4 columns)
plotdata <- records.sils[,1:4]

#Plot average silhouette values vs. number of records. Each point represents an average freshwater or marine silhoutte values from one of the taxonomic classes.
ggplot(plotdata, aes(x=record.number, y=av.sil, colour = Taxonomic.class, shape = Taxonomic.class)) + geom_point() + theme(axis.text.x = element_text(angle = 60, vjust = 0.5, hjust=0.5), plot.title = element_text(hjust = 0.5)) + xlab("Number of Records") + ylab("Average Silhouette Values") + ggtitle("Average Silhouette Values vs. Number of Records") + scale_colour_manual(values=label.colors)

####Check for low silhouette values in Cyprinidae, Onychopoda, Cottidae, Asellidae, Gammaridae----

chr.cyprinidae <- chr.Actino[[3]]
chr.onycho <- chr.Branchio[[1]]
chr.cottidae <- chr.Actino[[2]]
chr.asellidae <- chr.Malaco[[2]]
chr.gamm <- chr.Malaco[[5]]

#Obtain records with a silhouette indices below ~0.7

chr.cyprinidae.filt <- chr.cyprinidae %>% filter(sil_width < 0.5)
chr.onycho.filt <- chr.onycho %>% filter(sil_width < 0.7)
chr.cottidae.filt <- chr.cottidae %>% filter(sil_width < 0.7)
chr.asellidae.filt <- chr.asellidae %>% filter(sil_width < 0.75)
chr.gamm.filt <- chr.gamm %>% filter(sil_width < 0.7)

#Read in original data sets.
dataset.actino <- readRDS("datasetslistActino.RData")
dataset.branchio <- readRDS("datasetslistBranchio.RData")
dataset.malaco <- readRDS("datasetslistMalaco.RData")

#Subset taxa of interest.
dataset.cyprinidae <- dataset.actino[[3]]
dataset.onycho <- dataset.branchio[[1]]
dataset.cottidae <- dataset.actino[[2]]
dataset.asellidae <- dataset.malaco[[2]]
dataset.gamm <- dataset.malaco[[5]]  

#Convert record IDs to character format.
dataset.cyprinidae$recordID <- as.character(dataset.cyprinidae$recordID)
dataset.onycho$recordID <- as.character(dataset.onycho$recordID)
dataset.cottidae$recordID <- as.character(dataset.cottidae$recordID)
dataset.asellidae$recordID <- as.character(dataset.asellidae$recordID)
dataset.gamm$recordID <- as.character(dataset.gamm$recordID)

#Merge original data with silhouette value data.
merged.cyprinidae <- dplyr::left_join(chr.cyprinidae.filt, dataset.cyprinidae, by = "recordID")
merged.onycho <- dplyr::left_join(chr.onycho.filt, dataset.onycho, by ="recordID")
merged.cottidae <- dplyr::left_join(chr.cottidae.filt, dataset.cottidae, by ="recordID")
merged.asellidae <- dplyr::left_join(chr.asellidae.filt, dataset.asellidae, by = "recordID")
merged.gamm <- dplyr::left_join(chr.gamm.filt, dataset.gamm, by = "recordID")

#Set world object to plot points on world map.
world <- ne_countries(scale = "medium", returnclass = "sf")

#Obtain latitude and longitude of record samples with low silhouette values.
sites1 <- data.frame(longitude = merged.cyprinidae$lon, latitude = merged.cyprinidae$lat)
sites2 <- data.frame(longitude = merged.onycho$lon, latitude = merged.onycho$lat)
sites3 <- data.frame(longitude = merged.cottidae$lon, latitude = merged.cottidae$lat)
sites4 <- data.frame(longitude = merged.asellidae$lon, latitude = merged.asellidae$lat)
sites5 <- data.frame(longitude = merged.gamm$lon, latitude = merged.gamm$lat)

#Plot data points with low silhouette values on world map.
ggplot(data = world) +
  geom_sf() +
  geom_point(data = sites5, aes(x = longitude, y = latitude), size = 2, 
             shape = 23, fill = "red") + ggtitle("Gammaridae locations for sil values below 0.7")


```


